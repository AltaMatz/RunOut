from datetime import datetime
from flask import Flask  # type: ignore
import requests
from concurrent.futures import ThreadPoolExecutor  # <-- per chiamate in parallelo

app = Flask(__name__)

BASE_URL = "https://sipal.itispaleocapa.it/api/proxySipal"

aula = [
    # --- SENZA LETTERE ---
    "1-5", "1-8", "1-11", "1-12",
    "2-1", "2-2", "2-5", "2-6", "2-7",
    "3-3", "3-4", "3-5", "3-6",
    "3-11", "3-12", "3-13", "3-14",
    "2-12", "3-7", "3-8", "3-9", "3-10",
    "4-2", "4-3",
    "3-15", "3-16", "3-17", "3-18", "3-19", "3-20",
    "1-14", "1-15", "1-17",
    "1-90", "1-91", "1-92", "1-93", "1-94", "1-95", "1-96",
    "BASKIN",

    # --- CON LETTERE ---
    "E1-5", "E1-7", "E1-8", "E1-10",
    "E2-1", "E2-2", "E2-7", "E2-9",
    "E3-1", "E3-2", "E3-5", "E3-6", "E3-8",

    "I1-1", "I1-2", "I1-3", "I1-6", "I1-13",
    "I2-1", "I2-2", "I2-3", "I2-6", "I2-13",
    "I3-1", "I3-2", "I3-3", "I3-6", "I3-13",

    "LAB DIS - 1", "LAB DIS - 2", "LAB LTO",

    "M1-8", "M1-11", "M1-18", "M1-23",
    "M2-1", "M2-3", "M2-4", "M2-7",
    "M3-1", "M3-3", "M3-4", "M3-5", "M3-8",

    "PALESTRA 1", "PALESTRA 2", "SALA PESI",

    "T1-6", "T1-7", "T1-12", "T1-13", "T1-14",
    "T2-1", "T2-2", "T2-3", "T2-9",
    "T3-1", "T3-3", "T3-4", "T3-7", "T3-8"
]



# funzione che effettua UNA singola richiesta all’API
def fetch_aula(aula, giorno, ora):
    url = f"{BASE_URL}/studenti/classe/{giorno}/{ora}/{aula}"

    try:
        # timeout basso per non bloccare tutto
        response = requests.get(url, timeout=1)
        response.raise_for_status()

        data = response.json()

        return {
            "aula": aula,
            "risultato": data
        }

    except Exception as e:
        # se quell'aula non risponde, continuiamo comunque
        return {
            "aula": aula,
            "errore": str(e)
        }


# per velocizzare, utilizzare chiamate in parallelo
@app.route("/classi")
def classi():

    now = datetime.now()

    giorno = now.strftime("%Y-%m-%d")
    ora = now.strftime("%H:%M")

    risultati = []

    # pool di thread: esegue più richieste contemporaneamente
    # max_workers=20 = 20 richieste in parallelo
    with ThreadPoolExecutor(max_workers=20) as executor:

        # invio tutte le richieste in parallelo
        futures = [
            executor.submit(fetch_aula, a, giorno, ora)
            for a in aula
        ]

        # raccolgo i risultati man mano che arrivano
        for f in futures:
            risultati.append(f.result())

    return risultati


if __name__ == "__main__":
    app.run(debug=True)
